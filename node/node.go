package node

import (
	"context"
	"fmt"

	"git.sr.ht/~primalmotion/simplai/utils/render"
)

// Info holds the basic information about a Node. Every Node info can be
// accessed by calling node.Info(). This can be used to help identify a chain
// so it can be called by an agent.
type Info struct {
	Name        string
	Description string
	Parameters  string
}

// LogNode is a helper printing function to display information from a node.
func LogNode(n Node, color string, format string, kwargs ...any) { // lulz
	render.Box(
		fmt.Sprintf("[%s]\n\n", n.Info().Name)+fmt.Sprintf(format, kwargs...),
		color,
	)
}

// Node is the base object of the framework.
//
// A Node can be chained to another node. Together they form a chain.
//
//	[prompt:genstory] -> [llm:mistral] -> [prompt:summarize] -> [llm:zephyr]
//
// A chain can contains nest chains:
//
// [prompt:search] -> [ [prompt:summarize] -> [llm] ] -> [func:format] -> [llm]
//
// A node can be executed by calling its Execute method. The execution is given
// a context.Context and an Input. It returns a string and an eventual error.
// This output will then be fed to the next Node in the chain. This process
// continues until the execution reaches a node with no Next() Node. Then the
// output is unstacked and returned by the initial executed Node.
type Node interface {
	Info() Info
	Chain(Node)
	Next() Node
	Execute(context.Context, Input) (string, error)
}

// BaseNode is the generic implementation of a the Node interface. It is
// usually embedded into every kind of nodes.
type BaseNode struct {
	next Node
	info Info
}

// New creates a new *BaseNode with the given Info.
func New(info Info) *BaseNode {
	return &BaseNode{
		info: info,
	}
}

// Info returns the receiver's Info.
func (n *BaseNode) Info() Info {
	return n.info
}

// Chain chains the receiver with the given Node. When the receiver is
// executed, its generated output will be fed into the given Node. You cannot
// unlink a node. If you try to chain an already chained node the function will
// panic.
func (n *BaseNode) Chain(next Node) {
	if n.next != nil {
		panic(fmt.Sprintf(
			"node %s is already chained to %s",
			n.Info().Name,
			n.next.Info().Name,
		))
	}
	n.next = next
}

// Next returns the previously chained Node.
// It will return nil if the received has not
// been chained yet.
func (n *BaseNode) Next() Node {
	return n.next
}

// Execute starts the execution process of the chain, starting from the receiver.
// The given Input will be passed as is to the next Node, which will pass it on
// to the next, and so on. It will return the final output generated by the last
// Node in the chain.
//
// This does not do anything per se. It just provides the basic chaining mechanism
// to other kind of Nodes.
func (n *BaseNode) Execute(ctx context.Context, input Input) (output string, err error) {

	if next := n.Next(); next != nil {
		return next.Execute(ctx, input)
	}

	return input.Input(), nil
}
